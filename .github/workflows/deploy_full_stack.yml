# Deploy Full Stack - Refactored to use modular bash scripts
# See infrastructure/scripts/ for provisioning logic
name: Deploy Full Stack

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  VM_NAME: ${{ vars.GCP_VM_NAME || 'theatre-vm' }}
  MACHINE_TYPE: e2-medium
  IMAGE_FAMILY: debian-12
  IMAGE_PROJECT: debian-cloud
  BOOT_DISK_SIZE: 20GB
  CLOUD_INIT_FILE: infrastructure/cloud-init.yaml
  MEDIA_DISK_NAME: ${{ vars.GCP_MEDIA_DISK_NAME || 'theatre-media-disk' }}
  MEDIA_DISK_SIZE: 200GB
  MEDIA_DISK_TYPE: pd-standard
  SCRIPTS_DIR: /opt/theatre/scripts

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2

      - name: Ensure media disk exists
        run: |
          gcloud compute disks describe "${MEDIA_DISK_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --quiet 2>/dev/null || \
          gcloud compute disks create "${MEDIA_DISK_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --size="${MEDIA_DISK_SIZE}" --type="${MEDIA_DISK_TYPE}"

      - name: Ensure VM exists
        run: |
          gcloud compute instances describe "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --quiet 2>/dev/null || \
          gcloud compute instances create "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" \
            --machine-type="${MACHINE_TYPE}" --image-family="${IMAGE_FAMILY}" --image-project="${IMAGE_PROJECT}" \
            --boot-disk-size="${BOOT_DISK_SIZE}" --metadata-from-file=user-data="${CLOUD_INIT_FILE}" --tags=http-server,https-server

      - name: Ensure media disk is attached
        run: |
          gcloud compute instances describe "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --format="value(disks[].source)" | grep -q "${MEDIA_DISK_NAME}" || \
          gcloud compute instances attach-disk "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --disk="${MEDIA_DISK_NAME}" --device-name=media-disk

      - name: Ensure VM is running and get IP
        id: vm
        run: |
          STATUS=$(gcloud compute instances describe "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --format="value(status)")
          if [ "${STATUS}" != "RUNNING" ]; then
            gcloud compute instances start "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}"
            for i in {1..12}; do
              [ "$(gcloud compute instances describe "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --format="value(status)" 2>/dev/null)" = "RUNNING" ] && break
              sleep 5
            done
          fi
          echo "ip=$(gcloud compute instances describe "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --format="value(networkInterfaces[0].accessConfigs[0].natIP)")" >> "$GITHUB_OUTPUT"

      - name: Wait for SSH
        run: |
          for i in {1..30}; do
            gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command="true" --quiet 2>/dev/null && break
            echo "Waiting for SSH (${i}/30)..." && sleep 10
          done

      - name: Upload provisioning scripts
        run: |
          UPLOAD_DIR="/tmp/theatre-scripts-$$"
          # Step 1: Create a unique temp directory and upload scripts there
          gcloud compute ssh "${VM_NAME}" \
            --zone="${{ secrets.GCP_ZONE }}" \
            --project="${{ secrets.GCP_PROJECT_ID }}" \
            --command="mkdir -p ${UPLOAD_DIR}" \
            --quiet
          gcloud compute scp infrastructure/scripts/*.sh "${VM_NAME}:${UPLOAD_DIR}/" \
            --zone="${{ secrets.GCP_ZONE }}" \
            --project="${{ secrets.GCP_PROJECT_ID }}" \
            --quiet
          # Step 2: Move scripts to /opt/theatre/scripts using sudo and set permissions
          gcloud compute ssh "${VM_NAME}" \
            --zone="${{ secrets.GCP_ZONE }}" \
            --project="${{ secrets.GCP_PROJECT_ID }}" \
            --command="sudo mkdir -p ${SCRIPTS_DIR} && sudo mv ${UPLOAD_DIR}/*.sh ${SCRIPTS_DIR}/ && sudo chmod +x ${SCRIPTS_DIR}/*.sh && sudo chown root:root ${SCRIPTS_DIR}/*.sh && rm -rf ${UPLOAD_DIR}" \
            --quiet

      - name: Upload secrets and run provisioning
        run: |
          # Trap to ensure secrets.env is always cleaned up on exit (success, failure, or interrupt)
          cleanup_local_secrets() {
            rm -f /tmp/secrets.env
          }
          trap cleanup_local_secrets EXIT
          
          cat > /tmp/secrets.env << EOF
          GOCRYPTFS_PASSWORD=${GOCRYPTFS_PASSWORD}
          DUCKDNS_TOKEN=${DUCKDNS_TOKEN}
          DUCKDNS_DOMAIN=${DUCKDNS_DOMAIN}
          DOMAIN_NAME=${DOMAIN_NAME}
          REPO_URL=https://github.com/${{ github.repository }}.git
          EOF
          chmod 600 /tmp/secrets.env
          gcloud compute scp /tmp/secrets.env "${VM_NAME}:/tmp/secrets.env" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --quiet
          # Note: Local cleanup is now handled by the trap, so we remove the explicit rm here
          gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command="
            set -euo pipefail
            # Trap to ensure secrets.env is always cleaned up on the VM
            cleanup_vm_secrets() {
              rm -f /tmp/secrets.env
            }
            trap cleanup_vm_secrets EXIT
            sudo chmod 600 /tmp/secrets.env
            set -a && source /tmp/secrets.env && set +a
            
            # 1. Ensure disk exists and is formatted
            sudo -E ${SCRIPTS_DIR}/ensure_disk.sh
            
            # 2. Ensure disk is mounted
            sudo -E ${SCRIPTS_DIR}/ensure_disk_mount.sh
            
            # 3. Install dependencies (rsync, curl, jq) BEFORE migration
            sudo -E ${SCRIPTS_DIR}/install_dependencies.sh
            
            # 4. Install Docker if not present
            sudo -E ${SCRIPTS_DIR}/ensure_docker_installed.sh
            
            # 5. Migrate containerd to media disk (BEFORE Docker)
            sudo -E ${SCRIPTS_DIR}/migrate_containerd_root.sh
            
            # 6. Migrate Docker to media disk
            sudo -E ${SCRIPTS_DIR}/migrate_docker_root.sh
            
            # 7. Setup gocryptfs
            sudo -E ${SCRIPTS_DIR}/ensure_gocryptfs.sh
            
            # 8. Clone/update repository
            sudo -E ${SCRIPTS_DIR}/ensure_repo_clone.sh
            
            # 9. Setup DuckDNS
            sudo -E ${SCRIPTS_DIR}/ensure_duckdns.sh
            
            # 10. Create .env file
            sudo -E ${SCRIPTS_DIR}/ensure_env_file.sh
            
            # 11. Clean stale Jellyfin paths and volumes
            sudo -E ${SCRIPTS_DIR}/ensure_jellyfin_clean.sh
            
            # 12. Run additional compose cleanup
            sudo -E ${SCRIPTS_DIR}/ensure_compose_cleanup.sh
            
            # 13. Start docker-compose
            sudo -E ${SCRIPTS_DIR}/start_compose.sh
          "
        env:
          GOCRYPTFS_PASSWORD: ${{ secrets.GOCRYPTFS_PASSWORD }}
          DUCKDNS_TOKEN: ${{ secrets.DUCKDNS_TOKEN }}
          DUCKDNS_DOMAIN: ${{ vars.DUCKDNS_DOMAIN }}
          DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}

      - name: Verify deployment
        id: verify
        run: |
          gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command="
            # Run comprehensive verification (continue on warnings, fail on critical errors later)
            # verify_all.sh may have warnings for expected conditions like gocryptfs not being mounted
            sudo ${SCRIPTS_DIR}/verify_all.sh --skip-https || echo 'VERIFICATION_HAD_WARNINGS'
            
            # Run critical individual verification scripts (will fail the step if they fail)
            sudo ${SCRIPTS_DIR}/verify_mounts.sh
            sudo ${SCRIPTS_DIR}/verify_jellyfin_mount.sh
            sudo ${SCRIPTS_DIR}/verify_caddy.sh
          "
          echo "media=$(gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command='mountpoint -q /mnt/disks/media && echo MOUNTED || echo NOT_MOUNTED' --quiet)" >> "$GITHUB_OUTPUT"
          echo "gocryptfs=$(gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command='mountpoint -q /srv/library_clear && echo MOUNTED || echo NOT_MOUNTED' --quiet)" >> "$GITHUB_OUTPUT"
          echo "jellyfin=$(gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command='docker inspect --format="{{.State.Status}}" jellyfin 2>/dev/null || echo NOT_RUNNING' --quiet)" >> "$GITHUB_OUTPUT"
          echo "caddy=$(gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command='docker inspect --format="{{.State.Status}}" caddy 2>/dev/null || echo NOT_RUNNING' --quiet)" >> "$GITHUB_OUTPUT"
          echo "docker_root=$(gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command='docker info --format "{{.DockerRootDir}}" 2>/dev/null || echo UNKNOWN' --quiet)" >> "$GITHUB_OUTPUT"
          echo "containerd_root=$(gcloud compute ssh "${VM_NAME}" --project="${{ secrets.GCP_PROJECT_ID }}" --zone="${{ secrets.GCP_ZONE }}" --command='grep -E "^\s*root\s*=" /etc/containerd/config.toml 2>/dev/null | head -1 | sed -E "s/.*\"([^\"]+)\".*/\1/" || echo UNKNOWN' --quiet)" >> "$GITHUB_OUTPUT"

      - name: Verify HTTPS
        id: https
        if: vars.DOMAIN_NAME != ''
        run: |
          sleep 10
          for i in {1..12}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "https://${{ vars.DOMAIN_NAME }}" || echo "FAILED")
            [ "${STATUS}" = "200" ] || [ "${STATUS}" = "302" ] && break
            echo "Waiting for HTTPS (${i}/12)..." && sleep 10
          done
          echo "status=${STATUS}" >> "$GITHUB_OUTPUT"

      - name: Print deployment summary
        run: |
          echo "============================================================"
          echo "                 DEPLOYMENT SUMMARY"
          echo "============================================================"
          echo "VM: ${VM_NAME} (${{ steps.vm.outputs.ip }})"
          echo ""
          echo "Data Roots:"
          echo "  Docker: ${{ steps.verify.outputs.docker_root }}"
          echo "  containerd: ${{ steps.verify.outputs.containerd_root }}"
          echo ""
          echo "Mounts:"
          echo "  media: ${{ steps.verify.outputs.media }}"
          echo "  gocryptfs: ${{ steps.verify.outputs.gocryptfs }}"
          echo ""
          echo "Containers:"
          echo "  jellyfin: ${{ steps.verify.outputs.jellyfin }}"
          echo "  caddy: ${{ steps.verify.outputs.caddy }}"
          echo ""
          echo "HTTPS: ${{ steps.https.outputs.status || 'SKIPPED' }}"
          echo "============================================================"
          [ -n "${{ vars.DOMAIN_NAME }}" ] && echo "ðŸŽ¬ Visit: https://${{ vars.DOMAIN_NAME }}" || echo "ðŸŽ¬ Visit: http://${{ steps.vm.outputs.ip }}:8096"
          echo "============================================================"
